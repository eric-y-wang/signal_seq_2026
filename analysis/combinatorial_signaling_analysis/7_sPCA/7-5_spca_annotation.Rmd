---
title: "SIG13 sPCA program annotation"
author: "EYW"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    html_preview: false
---

```{r setup}
library(tidyverse)
library(patchwork)
library(viridisLite)
library(ggrepel)
library(ComplexHeatmap)
library(circlize)
library(RColorBrewer)
library(ggpointdensity)
library(scales)
library(viridisLite)

library(performance)
library(broom)
library(sandwich)   # robust vcov
library(MASS)       # rlm
library(quantreg)   # rq

knitr::opts_chunk$set(echo = TRUE)
set.seed(314)
```

```{r}
source("../../functions/r_custom/plotting_fxns.R")
theme_set(theme_Publication())
interaction_palette <- c("#808080",brewer.pal(5,"Dark2"))
names(interaction_palette) <- c("none", "additive over saturation", "buffering", 
                      "buffering complete", "synergy negative", "synergy positive")
```

# Goal

-   remove components correlated with technical factors
-   annotate sparse PCA programs based on ligands
-   annotate interaction effects in sparse PCA programs

# Import

```{r}
# import genes in components
features <- readr::read_csv("../../analysis_outs/spca/degs_zscore_allLigands/zscore_degs_allLigands_0.1_alpha1.0_sPCA_components.csv")
colnames(features)[-1] <- paste0("comp_",colnames(features)[-1])

# import GEP scores
codes <- readr::read_csv("../../analysis_outs/spca/degs_zscore_allLigands/zscore_degs_allLigands_0.1_alpha1.0_waggr_score.csv") 
codes <- codes %>%
  dplyr::mutate(replicate = str_extract(interaction, "rep[12]"))

# import gene-level interactions
interScored <- readr::read_csv("../../analysis_outs/glmGamPoi/interactions_scored_v3_glmGamPoi_0.05filter_sig.csv")
```

# Component Gene Numbers

```{r, fig.height=4, fig.width=12}
compNum <- features[,-1]
compNum <- tibble(components = names(compNum),
                  counts = colSums(compNum != 0))
ggplot(compNum, aes(x = components, y = counts)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

# Linear Modeling of GEP scores

To connect sparse PCA programs (GEPs) with specific ligands and technical factors, I will perform linear regression on scaled sparse PCA component scores with the following structure: scores = ligand1 + ligand2 + ligand1:ligand2 + replicate. Linker only will be used as the reference level (aka intercept).

P-value adjustment is performed across each globally.

I will perform lm with a robust covariance model given the lm assumption violations. Additionally, I will compare the lm outputs to rlm outputs to identify associations that may be driven by outliers.

## Run Model

```{r}
# center/scale and clean codes
mat <- codes %>%
  dplyr::mutate(across(where(is.numeric), ~ as.numeric(scale(.x)))) %>%
  column_to_rownames("interaction") %>%
  dplyr::select(where(is.numeric)) %>%
  as.matrix()

# Extract metadata from rownames
meta <- tibble(interaction = rownames(mat)) %>%
  separate(interaction, into = c("ligand1", "ligand2", "replicate"), sep = "_", remove = FALSE) %>%
  mutate(
    replicate = factor(replicate),
    ligand1   = fct_relevel(ligand1, "linker"),
    ligand2   = fct_relevel(ligand2, "linker")
  )

# Long format
df <- as.data.frame(mat) %>%
  rownames_to_column("interaction") %>%
  left_join(meta, by = "interaction") %>%
  mutate(interaction = gsub("_rep[12]","",interaction)) %>%
  mutate(interaction = fct_relevel(interaction, "linker_linker")) %>%
  pivot_longer(cols = starts_with("comp"), names_to = "component", values_to = "loading")
```

```{r}
# Ensure factors
df <- df %>%
  mutate(
    ligand1    = factor(ligand1),
    ligand2    = factor(ligand2),
    interaction= factor(interaction),
    replicate  = factor(replicate)
  )

# ---- Robust covariance helpers ----
# Robust SE
.robust_vcov <- function(mod) sandwich::vcovHC(mod, type = "HC3")

.tidy_ols_hc <- function(mod) broom::tidy(mod, conf.int = TRUE, vcov = .robust_vcov(mod))

# Robust estimation (Huber) â€” coefficients may shift if outliers matter
.fit_rlm <- function(d, fml) MASS::rlm(fml, data = d, psi = psi.huber)
.tidy_rlm <- function(mod) broom::tidy(mod)  # treat as sensitivity (SEs are large-sample)

# =========================
# Model 1: loading ~ ligand1 * ligand2 + replicate
# =========================
interaction_models <- df %>%
  group_by(component) %>%
  nest() %>%
  mutate(
    model_ols   = map(data, ~ lm(loading ~ ligand1 * ligand2 + replicate, data = .x)),
    tidy_ols_hc = map(model_ols, .tidy_ols_hc),
    glance_ols  = map(model_ols, glance),
    augment_ols = map(model_ols, augment),

    model_rlm   = map(data, ~ .fit_rlm(.x, loading ~ ligand1 * ligand2 + replicate)),
    tidy_rlm    = map(model_rlm, .tidy_rlm)
  )

# OLS+HC coefficient table with BH adjust globally
lm_interaction <- interaction_models %>%
  dplyr::select(component, tidy_ols_hc) %>%
  unnest(tidy_ols_hc) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p.value, method = "BH"))

rlm_interaction <- interaction_models %>%
  dplyr::select(component, tidy_rlm) %>%
  unnest(tidy_rlm)
```

## Compare RLM to LM

```{r}
joint_interaction <- left_join(lm_interaction, rlm_interaction,
                               by = c("component","term"),
                               suffix = c("_lm","_rlm"))
```

```{r}
joint_interaction %>%
  ggplot(aes(x = estimate_lm, y = estimate_rlm)) +
    geom_point()
```

There's a near perfect correlation of robust LM estimates and OLS estimates, suggesting that outliers are not strongly driving any particular component

## Identify replicate-driven components

Here, I want to identify and remove components that are primarily driven by technical factors. This will specifically manifest as those that are highly associated with technical replicates

### Visualize replicate associations

```{r, fig.width=14, fig.height=5}
lm_interaction %>%
  filter(p_adj < 0.01) %>%
  mutate(is_replicate_association = grepl("replicate", term)) %>%
  ggplot(aes(x = component, y = -log10(p_adj), color = is_replicate_association, size = abs(estimate))) +
  geom_point() +
  scale_color_manual(values = c("FALSE" = "black", "TRUE" = "red")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5))
```

### Filter replicate-driven componets

I will take a conservative approach and remove any component where the most significant association is replicate.

```{r}
bad_rep_comps <- lm_interaction %>%
  group_by(component) %>%
  slice_min(p_adj, with_ties = FALSE) %>%
  filter(grepl("replicate", term)) %>%
  pull(component)

bad_rep_comps
```

```{r}
# make filtered lm tibble
lm_interaction_filtered <- lm_interaction %>%
  filter(!(component %in% bad_rep_comps))
```

```{r}
# count number of components remaining
lm_interaction_filtered %>%
  pull(component) %>%
  unique() %>%
  length()
```

# Classify interaction effects

Here, I will take a similar approach as in the gene-level analysis and identify synergy, buffering and purely additive effects

```{r}
# make formated tibble
l1 <- lm_interaction_filtered %>% 
  filter(grepl("^ligand1", term)) %>% 
  transmute(component,
            ligand1 = sub("^ligand1", "", term),
            estimate_ligand1 = estimate,
            p_adj_ligand1 = p_adj)
l2 <- lm_interaction_filtered %>% 
  filter(grepl("^ligand2", term)) %>% 
  transmute(component,
            ligand2 = sub("^ligand2", "", term),
            estimate_ligand2 = estimate,
            p_adj_ligand2 = p_adj)
int <- lm_interaction_filtered %>% 
  filter(grepl("^ligand1.+:ligand2", term)) %>%
  separate(term, c("l1","l2"), sep = ":", remove = FALSE) %>%
  transmute(component,
            ligand1 = sub("^ligand1", "", l1),
            ligand2 = sub("^ligand2", "", l2),
            interaction = paste0(ligand1, "_", ligand2),
            estimate_interaction = estimate,
            p_adj_interaction = p_adj)

# assemble
out <- int %>%
  left_join(l1, by = c("component","ligand1"), relationship = "many-to-many") %>%
  left_join(l2, by = c("component","ligand2"), relationship = "many-to-many") %>%
  arrange(component, ligand1, ligand2)
```

```{r}
lm_scored <- out %>%
  mutate(estimate_total_interaction_model = (estimate_ligand1+estimate_ligand2+estimate_interaction),
         interaction_score = case_when(p_adj_interaction > 0.05 ~ 0,
                                       p_adj_interaction <= 0.05 ~ (estimate_interaction/(estimate_total_interaction_model)))) %>%
    mutate(interaction_class = case_when(
        # conditions are evaluated sequentially
        p_adj_interaction <= 0.05 & estimate_total_interaction_model > 0 & interaction_score > 0 ~ "synergy positive",
        p_adj_interaction <= 0.05 & estimate_total_interaction_model < 0 & interaction_score > 0 ~ "synergy negative",
        p_adj_interaction <= 0.05 & interaction_score < 0 ~ "buffering",
        p_adj_interaction > 0.05 ~ "none"
        ))
```

## Merge with gene-level analysis

Here I will merge the program features with the gene-level analysis of interaction effects.

```{r}
spca_genes <- features %>%
  pivot_longer(-gene, names_to = "spca_component", values_to = "loading") %>%
  filter(loading != 0) %>%
  arrange(spca_component,desc(loading))

interScored_minimal <- interScored %>%
  dplyr::select(name, interaction, interaction_class) %>%
  mutate(interaction = gsub("\\.","_", interaction)) %>%
  rename(interaction_class_gene = interaction_class)

# create annotated lm_scored with proportion of synergy and buffering
# genes out of total for every component and interaction
lm_scored_anno <- lm_scored %>%
  left_join(spca_genes, by = c("component" = "spca_component"), relationship = "many-to-many") %>%
  left_join(interScored_minimal, by = c("gene" = "name","interaction")) %>%
  group_by(across(-c(gene, loading, interaction_class_gene))) %>%
  count(interaction_class_gene, name = "n") %>%
  mutate(prop = n / sum(n))  %>%
  ungroup() %>%
  filter(interaction_class_gene != "none") %>%
  pivot_wider(id_cols = -n,
              names_from = interaction_class_gene,
              names_prefix = "freq_",
              values_from = prop,
              values_fill = 0)
```

# Visualize GEP interaction effects

## Bar-plot of interactions per GEP

```{r, fig.height=10, fig.width=8}
lm_scored %>%
  filter(p_adj_interaction < 0.01 | p_adj_ligand1 < 0.01 | p_adj_ligand2 < 0.01) %>%
  mutate(interaction_class = factor(interaction_class, levels = names(interaction_palette))) %>%
  count(component, interaction_class, name = "n") %>%
  group_by(component) %>%
  mutate(freq = n / sum(n)) %>%
  ungroup() %>%
  filter(interaction_class != "none") %>%
  ggplot(aes(x = n, y = component, fill = interaction_class)) +
  geom_col() +
  scale_fill_manual(values = interaction_palette, breaks = names(interaction_palette))
```

## Heatmap + bar-plot of interactions

```{r}
lm_interaction_res <- lm_interaction_filtered %>%
  filter(grepl("^ligand1.*:ligand2.*$", term)) %>%
  mutate(term = gsub("ligand[12]","",term)) %>%
  mutate(term = gsub(":","_",term)) %>%
  mutate(p_score = -log10(p_adj))

lm_single_res <- lm_interaction_filtered %>%
  filter(!grepl("^ligand1.*:ligand2.*$", term)) %>%
  filter(grepl("ligand",term)) %>%
  mutate(p_score = -log10(p_adj))
```

```{r, fig.height=12, fig.width=9}
class_levels <- setdiff(names(interaction_palette), "none")

# pull out significant ligands
sig_ligands <- {
  x <- lm_single_res %>% filter(p_adj < 0.05) %>% pull(term) %>% unique()
  x <- sub("^ligand1(.+)$", "\\1_linker", x)
  sub("^ligand2(.+)$", "linker_\\1", x)
}
sig_ligands <- sig_ligands[!(sig_ligands %in% c("linker_TNF","linker_IL2","linker_IL6","linker_IL27","linker_IL4","linker_IL21","linker_IFNG","linker_IL7"))]

# make heatmap matrix
mat <- codes %>%
  dplyr::select(-any_of(bad_rep_comps)) %>%
  mutate(interaction = gsub("_rep[12]", "", interaction)) %>%
  group_by(interaction) %>%
  summarise(across(where(is.numeric), ~mean(.x, na.rm = TRUE)), .groups = "drop") %>%
  # scale before filtering for single ligands
  mutate(across(where(is.numeric), ~as.numeric(scale(.x)))) %>%
  filter(interaction %in% sig_ligands) %>%
  mutate(interaction = gsub("^linker_|_linker","",interaction)) %>%
  column_to_rownames("interaction") %>% as.matrix() %>% t()

# make heatmap color scale
col_fun <- colorRamp2(seq(-6, 6, length.out = 11), rev(brewer.pal(11, "RdBu")))

# make bar plot
bar_mat <- lm_scored %>%
  filter(p_adj_interaction < 0.05 | p_adj_ligand1 < 0.05 | p_adj_ligand2 < 0.05) %>%
  filter(interaction_class != "buffering") %>%
  #filter(interaction_class %in% class_levels) %>%
  mutate(interaction_class = factor(interaction_class, levels = class_levels)) %>%
  count(component, interaction_class, name = "n") %>%
  complete(component, interaction_class, fill = list(n = 0)) %>%
  pivot_wider(names_from = interaction_class, values_from = n, names_expand = TRUE, values_fill = 0) %>%
  column_to_rownames("component") %>% as.matrix()

common <- intersect(rownames(mat), rownames(bar_mat))
mat <- mat[common, , drop = FALSE]
bar_mat <- bar_mat[common, class_levels, drop = FALSE]

ht <- Heatmap(mat, name = "scaled sPCA loadings",
              col = col_fun,
              cluster_rows = TRUE, cluster_columns = TRUE,
              row_names_side = "left",
              border_gp = gpar(col = "black"),
              heatmap_legend_param = list(title = "scaled\nsPCA\nloadings",
                                          at = seq(-6, 6, by = 3), color_bar = "continuous"))

bars <- rowAnnotation(
  num_interactions = anno_barplot(bar_mat, gp = gpar(fill = interaction_palette[class_levels]),
                       axis_param = list(side = "bottom")),
  width = unit(45, "mm")
)

bar_legend <- Legend(title = "interaction class", at = class_levels,
                     legend_gp = gpar(fill = interaction_palette[class_levels]))

# Assign the draw result to an object
ht_obj <- draw(ht + bars, annotation_legend_list = list(bar_legend),
      heatmap_legend_side = "right", annotation_legend_side = "right")

# Extract the components in their clustered order
clustered_rows <- tibble(component = rownames(mat)[row_order(ht_obj)])
```

## Full Heatmap

```{r, fig.height=8, fig.width=10}
# scale and clean codes
mat <- codes %>%
  dplyr::select(-any_of(bad_rep_comps))  %>%
  dplyr::mutate(interaction = gsub("_rep[12]","",interaction)) %>%
  group_by(interaction) %>%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
  dplyr::mutate(across(where(is.numeric), ~ as.numeric(scale(.x, center=F)))) %>%
  column_to_rownames("interaction") %>%
  as.matrix()

# extract ligand1 from rownames (before transposing!)
interaction_names <- rownames(mat)
ligand1_vec <- sapply(strsplit(interaction_names, "_"), `[`, 1)

# build column annotation (applies to columns *after* transpose)
col_anno <- HeatmapAnnotation(
  ligand1 = ligand1_vec,
  col = list(ligand1 = setNames(brewer.pal(length(unique(ligand1_vec)), "Set3"), unique(ligand1_vec)))
)

# transpose
mat <- t(mat)

col_fun <- colorRamp2(
  seq(-6, 6, length.out = 11),
  rev(brewer.pal(n = 11, name = "RdBu"))
)

# Plot
hm_full <- Heatmap(
  mat,
  name = "scaled sPCA loadings",
  col = col_fun,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = FALSE,
  top_annotation = col_anno,
  column_title = "sPCA components across interactions\nmean across replicates",
  heatmap_legend_param = list(
    title = "scaled sPCA\nloadings",
    at = seq(-6, 6, by = 3),
    color_bar = "continuous"
  )
)
draw(hm_full)
```

## Scatterplot of Top 3 scores for single and combinatorial

```{r, fig.width=12, fig.height=4}
df <- codes %>%
  dplyr::select(-any_of(bad_rep_comps)) %>%
  mutate(interaction = gsub("_rep[12]", "", interaction)) %>%
  group_by(interaction) %>%
  summarise(across(where(is.numeric), ~mean(.x, na.rm = TRUE)), .groups = "drop") %>%
  mutate(across(where(is.numeric), ~as.numeric(scale(.x)))) %>%
  pivot_longer(-interaction, names_to = "component", values_to = "scaled_score") %>%
  mutate(is_single = ifelse(grepl("linker", interaction),"yes","no")) %>%
  left_join(lm_scored, by = c("interaction", "component")) %>%
  mutate(filter_col = case_when(is_single == "no" & interaction_class == "none" ~ "remove",
                                TRUE ~ "keep")) %>%
  #filter(filter_col != "remove") %>%
  group_by(component, is_single) %>%
  slice_max(order_by = scaled_score, n=3) %>%
  # Calculate difference (yes - no) and reorder component factor
  group_by(component) %>%
  mutate(diff_val = mean(scaled_score[is_single == "yes"]) - mean(scaled_score[is_single == "no"])) %>%
  ungroup() %>%
  mutate(component = reorder(component, diff_val))

single_v_comb_plot <- df %>%
  ggplot(aes(x = component, y = scaled_score, color = is_single)) +
  geom_point(alpha=0.5) +
  scale_color_manual(values = c("red","black")) +
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5)) +
  ggtitle("Distribution scaled sPCA score for top 3 conditions\nsingle vs combinatorial")
single_v_comb_plot
```







